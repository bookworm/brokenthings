# Intro

I've read allot of business books over the years and for the most part to put it bluntly, they sucked. They all have one
thing in common which I like to call the system pitfall. They try very hard and some very eloquently describe a system a
methodology by which they have succeeded. The problem with this approach is that the methodologies, models, and processes by
which a successful business is built are continually changing and at a ever increasing rate. The reality is that with a few
exceptions, a approach doesn't usually even work by the time it's published in a book. If it was still effective they
wouldn't be writing they would be making money.

Nicholas Taleb although from completely different direction, touched on this quite well in his book The Black Swan. For too
long we've been a society obsessed with figures and facts, the directly tangible is marketable -- risk doesn't sell. Not many
would buy a book "You might make allot of money" or go to a business school where the professors tell you "You might be
wasting your money on this education", such things simply don't fly well. In reality business is far from tangible and rigid
it is fluid and ever changing. Things valid today might be completely invalid tomorrow, what brings success now may bring
failure later.


Now this bring me to my point or points if you may. Whether or not your book is valuable does not depend on your
methodologies, your business models, your techniques etc it is valuable if you're a good businessman and can help the reader
understand why. Your current formula will fail I have no delusions that I'll learn some magic long lasting formula that will
change my life forever. What I want to learn is how you reached that formula, how did you discover these methods. What was
the thought process that brought you to it, what was the inspiration in other words how is it that your business mind works?

# It is valuable if     

Programming is a craft. At its simplest, it comes down to getting a computer to do what you want it to do (or what your user
wants it to do). As a programmer, you are part listener, part advisor, part interpreter, and part dictator. You try to
capture elusive requirements and find a way of expressing them so that a mere machine can do them justice. You try to
document your work so that others can understand it, and you try to engineer your work so that others can build on it. What's
more, you try to do all this against the relentless ticking of the project clock. You work small miracles every day.

# It's a difficult job.

There are many people offering you help. Tool vendors tout the miracles their products perform. Methodology gurus promise
that their techniques guarantee results. Everyone claims that their programming language is the best, and every operating
system is the answer to all conceivable ills.

Of course, none of this is true. There are no easy answers. There is no such thing as a best solution, be it a tool, a
language, or an operating system. There can only be systems that are more appropriate in a particular set of circumstances.

This is where pragmatism comes in. You shouldn't be wedded to any particular technology, but have a broad enough background
and experience base to allow you to choose good solutions in particular situations. Your background stems from an
understanding of the basic principles of computer science, and your experience comes from a wide range of practical projects. 

@ Theory and practice combine to make you strong.

You adjust your approach to suit the current circumstances and environment. You judge the relative importance of all the
factors affecting a project and use your experience to produce appropriate solutions. And you do this continuously as the
work progresses. Pragmatic Programmers get the job done, and do it well.       

Unfortunately, knowledge isn't stable. It changes—often and rapidly. Your understanding of a requirement may change following
a meeting with the client. The government changes a regulation and some business logic gets outdated. Tests may show that the
chosen algorithm won't work. All this instability means that we spend a large part of our time in maintenance mode,
reorganizing and re-expressing the knowledge in our systems.   

Engineers prefer simple, single solutions to problems. Math tests that allow you to proclaim with great confidence that x = 2
are much more comfortable than fuzzy, warm essays about the myriad causes of the French Revolution. Management tends to agree
with the engineers: single, easy answers fit nicely on spreadsheets and project plans.

If only the real world would cooperate. Unfortunately, while x is 2 today, it may need to be 5 tomorrow, and 3 next week.
Nothing is forever—and if you rely heavily on some fact, you can almost guarantee that it will change.

There is always more than one way to implement something, and there is usually more than one vendor available to provide a
third-party product. If you go into a project hampered by the myopic notion that there is only one way to do it, you're in
for an unpleasant wake up call.

Many project teams have their eyes forcibly opened as the future unfolds: